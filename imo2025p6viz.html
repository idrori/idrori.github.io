<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IMO 2025 Problem 6 Visualization</title>
  <!-- Responsive viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    h1 {
      margin-bottom: 0.2em;
    }
    .controls {
      margin-top: 1em;
      margin-bottom: 1em;
    }
    #grid {
      display: inline-block;
      border: 1px solid #333;
      margin-top: 1em;
    }
    .cell {
      width: 20px;
      height: 20px;
      box-sizing: border-box;
      border: 1px solid #eee;
      display: inline-block;
    }
    .legend {
      margin-top: 1em;
    }
    .legend div {
      margin-bottom: 0.3em;
    }
    .info {
      margin-top: 2em;
      max-width: 800px;
    }
    /* New modern styling overrides */
    /* Base styling */
    body {
      margin: 0;
      padding: 0;
      background: #f5f7fa;
      color: #333;
      line-height: 1.5;
    }
    h1 {
      margin: 0;
      margin-bottom: 0.5em;
      font-size: 2em;
      font-weight: 600;
      color: #2c3e50;
    }
    p {
      margin-bottom: 1em;
    }
    .container {
      max-width: 900px;
      margin: 2em auto;
      background: #ffffff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      position: relative;
    }
    .header-image {
      width: 100%;
      height: 160px;
      object-fit: cover;
      object-position: center;
      display: block;
      margin: -1.5em -1.5em 1em -1.5em;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5em;
      margin-top: 1em;
      margin-bottom: 1em;
    }
    .controls label {
      margin-right: 0.5em;
      font-weight: 500;
      white-space: nowrap;
    }
    .controls input[type='range'] {
      flex: 1;
      min-width: 120px;
      -webkit-appearance: none;
      height: 6px;
      border-radius: 3px;
      background: #dfe6ed;
      outline: none;
    }
    .controls input[type='range']::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #1f78b4;
      cursor: pointer;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
    }
    .controls input[type='range']::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #1f78b4;
      cursor: pointer;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
    }
    #kValue {
      font-weight: 600;
      margin-left: 0.5em;
      color: #1f78b4;
    }
    #grid {
      display: inline-block;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-top: 1em;
      margin-left: auto;
      margin-right: auto;
      overflow-x: auto;
      max-width: 100%;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }
    .cell {
      width: 20px;
      height: 20px;
      box-sizing: border-box;
      border: 1px solid #f0f0f0;
      display: inline-block;
      transition: background-color 0.3s ease;
    }
    .legend {
      margin-top: 1em;
      font-size: 0.9em;
    }
    .legend div {
      margin-bottom: 0.3em;
      display: flex;
      align-items: center;
      gap: 0.5em;
    }
    .info {
      margin-top: 2em;
      max-width: 100%;
    }
    #tileCount {
      font-weight: 600;
      color: #1f78b4;
      margin-top: 0.5em;
      font-size: 1.1em;
    }
    @media (max-width: 600px) {
      h1 {
        font-size: 1.6em;
      }
      .container {
        margin: 1em auto;
        padding: 1em;
      }
      .controls {
        flex-direction: column;
        align-items: flex-start;
      }
      .controls label {
        margin-bottom: 0.3em;
      }
      .controls input[type='range'] {
        width: 100%;
      }
      .info {
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <img src="imo_header.png" alt="" class="header-image">
    <h1>IMO 2025 Problem 6 Visualizer</h1>
    <p>This visualization helps you explore the solution. The problem asks for the minimum number of rectangular tiles needed to cover an n×n grid so that every row and column has exactly one uncovered unit square.</p>

    <div class="controls">
    <label for="kInput">Choose the block size k (where n = k<sup>2</sup>):</label>
    <!-- Restrict k to small values (1–4) to visualise correct patterns for k=2,3,4 -->
    <input id="kInput" type="range" min="1" max="4" value="2" step="1" oninput="updateGrid()">
    <span id="kValue">2</span>
    </div>

    <div id="grid"></div>

    <div class="legend">
      <div><span style="display:inline-block;width:18px;height:18px;background:#ffffff;border:1px solid #333;margin-right:0.5em;"></span> Uncovered cell (one per row and column)</div>
    </div>

    <div class="info">
     <p>The minimum number of tiles needed for an n×n grid is given by<br>
      T(n) = n + 2&nbsp;floor(√n)&nbsp;−&nbsp;3.<br>
      When n is a perfect square, n = k<sup>2</sup>, this simplifies to T(n) = k<sup>2</sup> + 2k − 3.  The formula is displayed below for the chosen k.</p>
    <p id="tileCount"></p>
   <p>This visualizer focuses on the case where n is a perfect square (choose k using the slider). The structures you see here generalize to larger grids.</p>
    </div>
  </div> <!-- end container -->

  <script>
    // Predefined colour palette for off-diagonal blocks
    const palette = [
      '#a6cee3', '#b2df8a', '#fb9a99', '#fdbf6f', '#cab2d6', '#ffff99', '#1f78b4', '#33a02c', '#e31a1c', '#ff7f00', '#6a3d9a'
    ];

    function updateGrid() {
      const kInput = document.getElementById('kInput');
      const k = parseInt(kInput.value);
      document.getElementById('kValue').textContent = k;
      const n = k * k;
      const gridDiv = document.getElementById('grid');
      gridDiv.innerHTML = '';
      // Set grid width dynamically
      // Determine drawing mode. For small k (<= blockThreshold) we display every unit cell;
      // for larger k we compress each k×k block into one cell to keep the visual manageable.
      const blockThreshold = 10;
      // Compute cell size: for small grids, use 20px; for large, scale to fit within 800px width.
      let cellSize;
      if (k > blockThreshold) {
        cellSize = Math.max(4, Math.floor(800 / k));
      } else {
        cellSize = 20;
      }
      gridDiv.style.width = (cellSize * (k > blockThreshold ? k : n)) + 'px';

      // Prepare tile count and cell colouring logic
      let tileCount;
      // Predefine colours for special cases (k == 2) to illustrate windmill tiling
      const windmillColours = ['#a6cee3', '#b2df8a', '#fb9a99', '#fdbf6f', '#cab2d6'];

      // Handle special small case k = 1
      if (k === 1) {
        tileCount = 0;
        document.getElementById('tileCount').innerHTML = `For k = ${k} (n = ${n}), the minimum number of tiles is <strong>${tileCount}</strong>.`;
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.style.width = cellSize + 'px';
        cell.style.height = cellSize + 'px';
        cell.style.background = '#ffffff';
        cell.style.border = '1px solid #333';
        gridDiv.appendChild(cell);
        return;
      }

      // Predefined tilings for k = 2, 3, 4.  Each entry specifies the grid size n, a list of hole positions (uncovered cells),
      // a mapping from "r,c" strings to tile indices, and the total tile count.  These patterns are precomputed to illustrate
      // the optimal tilings for small k.  When a custom tiling is available for the selected k, the visualiser will use it.
      const customTilings = {
        2: {
          n: 4,
          holes: ['0,1','1,3','2,0','3,2'],
          mapping: {
            '1,1':0,'1,2':0,'2,1':0,'2,2':0,
            '0,0':1,'1,0':1,
            '0,2':2,'0,3':2,
            '2,3':3,'3,3':3,
            '3,0':4,'3,1':4
          },
          tileCount: 5
        },
        3: {
          n: 9,
          holes: ['0,2','1,5','2,8','3,1','4,4','5,7','6,0','7,3','8,6'],
          mapping: {
            '1,2':0,'1,3':0,'1,4':0,'2,2':0,'2,3':0,'2,4':0,'3,2':0,'3,3':0,'3,4':0,
            '2,5':1,'2,6':1,'3,5':1,'3,6':1,'4,5':1,'4,6':1,'2,7':1,'3,7':1,'4,7':1,
            '4,1':2,'4,2':2,'4,3':2,'5,1':2,'5,2':2,'5,3':2,'6,1':2,'6,2':2,'6,3':2,
            '5,4':3,'5,5':3,'5,6':3,'6,4':3,'6,5':3,'6,6':3,'7,4':3,'7,5':3,'7,6':3,
            '0,0':4,'1,0':4,'2,0':4,'3,0':4,'4,0':4,'5,0':4,
            '0,1':5,'1,1':5,'2,1':5,
            '0,3':6,'0,4':6,'0,5':6,'0,6':6,'0,7':6,'0,8':6,
            '1,6':7,'1,7':7,'1,8':7,
            '3,8':8,'4,8':8,'5,8':8,'6,8':8,'7,8':8,'8,8':8,
            '6,7':9,'7,7':9,'8,7':9,
            '7,0':10,'7,1':10,'7,2':10,
            '8,0':11,'8,1':11,'8,2':11,'8,3':11,'8,4':11,'8,5':11
          },
          tileCount: 12
        },
        4: {
          n: 16,
          holes: ['0,3','1,7','2,11','3,15','4,2','5,6','6,10','7,14','8,1','9,5','10,9','11,13','12,0','13,4','14,8','15,12'],
          mapping: {
            // 9 block tiles of size 4×4.  Each block covers rows r..r+3 and cols c..c+3.  In the previous
            // version some rows were omitted; here we include the full 4×4 area for each block tile.
            '1,3':0,'1,4':0,'1,5':0,'1,6':0,'2,3':0,'2,4':0,'2,5':0,'2,6':0,'3,3':0,'3,4':0,'3,5':0,'3,6':0,'4,3':0,'4,4':0,'4,5':0,'4,6':0,
            '2,7':1,'2,8':1,'2,9':1,'2,10':1,'3,7':1,'3,8':1,'3,9':1,'3,10':1,'4,7':1,'4,8':1,'4,9':1,'4,10':1,'5,7':1,'5,8':1,'5,9':1,'5,10':1,
            '3,11':2,'3,12':2,'3,13':2,'3,14':2,'4,11':2,'4,12':2,'4,13':2,'4,14':2,'5,11':2,'5,12':2,'5,13':2,'5,14':2,'6,11':2,'6,12':2,'6,13':2,'6,14':2,
            '5,2':3,'5,3':3,'5,4':3,'5,5':3,'6,2':3,'6,3':3,'6,4':3,'6,5':3,'7,2':3,'7,3':3,'7,4':3,'7,5':3,'8,2':3,'8,3':3,'8,4':3,'8,5':3,
            '6,6':4,'6,7':4,'6,8':4,'6,9':4,'7,6':4,'7,7':4,'7,8':4,'7,9':4,'8,6':4,'8,7':4,'8,8':4,'8,9':4,'9,6':4,'9,7':4,'9,8':4,'9,9':4,
            '7,10':5,'7,11':5,'7,12':5,'7,13':5,'8,10':5,'8,11':5,'8,12':5,'8,13':5,'9,10':5,'9,11':5,'9,12':5,'9,13':5,'10,10':5,'10,11':5,'10,12':5,'10,13':5,
            '9,1':6,'9,2':6,'9,3':6,'9,4':6,'10,1':6,'10,2':6,'10,3':6,'10,4':6,'11,1':6,'11,2':6,'11,3':6,'11,4':6,'12,1':6,'12,2':6,'12,3':6,'12,4':6,
            '10,5':7,'10,6':7,'10,7':7,'10,8':7,'11,5':7,'11,6':7,'11,7':7,'11,8':7,'12,5':7,'12,6':7,'12,7':7,'12,8':7,'13,5':7,'13,6':7,'13,7':7,'13,8':7,
            '11,9':8,'11,10':8,'11,11':8,'11,12':8,'12,9':8,'12,10':8,'12,11':8,'12,12':8,'13,9':8,'13,10':8,'13,11':8,'13,12':8,'14,9':8,'14,10':8,'14,11':8,'14,12':8,
            '0,0':9,'1,0':9,'2,0':9,'3,0':9,'4,0':9,'5,0':9,'6,0':9,'7,0':9,'8,0':9,'9,0':9,'10,0':9,'11,0':9,
            '0,1':10,'1,1':10,'2,1':10,'3,1':10,'4,1':10,'5,1':10,'6,1':10,'7,1':10,
            '0,2':11,'1,2':11,'2,2':11,'3,2':11,
            '0,4':12,'0,5':12,'0,6':12,'0,7':12,'0,8':12,'0,9':12,'0,10':12,'0,11':12,'0,12':12,'0,13':12,'0,14':12,'0,15':12,
            '1,8':13,'1,9':13,'1,10':13,'1,11':13,'1,12':13,'1,13':13,'1,14':13,'1,15':13,
            '2,12':14,'2,13':14,'2,14':14,'2,15':14,
            '4,15':15,'5,15':15,'6,15':15,'7,15':15,'8,15':15,'9,15':15,'10,15':15,'11,15':15,'12,15':15,'13,15':15,'14,15':15,'15,15':15,
            // Red vertical stripe of length 7 in column 14 (rows 8–14).  Do not include row 15 here; the cell (15,14)
            // is part of the purple “cross” tile below.
            '8,14':16,'9,14':16,'10,14':16,'11,14':16,'12,14':16,'13,14':16,'14,14':16,
            // Purple “cross” tile: vertical stripe in column 13 (rows 12–15) plus a single cell at (15,14)
            '12,13':17,'13,13':17,'14,13':17,'15,13':17,'15,14':20,
            '13,0':18,'13,1':18,'13,2':18,'13,3':18,
            '14,0':19,'14,1':19,'14,2':19,'14,3':19,'14,4':19,'14,5':19,'14,6':19,'14,7':19,
            '15,0':20,'15,1':20,'15,2':20,'15,3':20,'15,4':20,'15,5':20,'15,6':20,'15,7':20,'15,8':20,'15,9':20,'15,10':20,'15,11':20
          },
          tileCount: 21
        }
      };

      // If a custom tiling is defined for this k, draw that tiling and return.
      if (customTilings[k]) {
        const tiling = customTilings[k];
        tileCount = tiling.tileCount;
        document.getElementById('tileCount').innerHTML = `For k = ${k} (n = ${n}), the minimum number of tiles is <strong>${tileCount}</strong> (= k^2 + 2k − 3).`;
        const holes = new Set(tiling.holes);
        // Assign colours to tiles.  We want the k×k block tiles to have distinct colours
        // separate from the long stripe tiles.  For k=2,3,4 the number of k×k blocks is
        // given by (k-1)^2 (1 for k=2, 4 for k=3, and 9 for k=4).  Use the first
        // blockTileCount colours from the palette for these blocks, and assign the
        // remaining tiles colours from the tail of the palette (cycling if necessary).
        const blockTileCountLookup = {2: 1, 3: 4, 4: 9};
        const blockTileCount = blockTileCountLookup[k] || 0;
        const tileColours = [];
        // Create a palette for stripe tiles by taking colours after the block palette.
        // If the palette is shorter than the number of block tiles, use modulo indexing.
        const stripePalette = palette.slice(blockTileCount % palette.length);
        for (let i = 0; i < tileCount; i++) {
          if (i < blockTileCount) {
            tileColours[i] = palette[i % palette.length];
          } else {
            // Assign stripe colours from the stripePalette, cycling as needed.  If the
            // stripePalette is empty (this can happen if blockTileCount >= palette.length),
            // fall back to cycling through the full palette starting after blockTileCount.
            if (stripePalette.length > 0) {
              tileColours[i] = stripePalette[(i - blockTileCount) % stripePalette.length];
            } else {
              tileColours[i] = palette[(i - blockTileCount) % palette.length];
            }
          }
        }
        for (let r = 0; r < tiling.n; r++) {
          for (let c = 0; c < tiling.n; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.style.width = cellSize + 'px';
            cell.style.height = cellSize + 'px';
            const key = `${r},${c}`;
            if (holes.has(key)) {
              cell.style.background = '#ffffff';
              cell.style.border = '1px solid #333';
            } else {
              const tileIndex = tiling.mapping[key];
              cell.style.background = tileColours[tileIndex % tileColours.length];
            }
            gridDiv.appendChild(cell);
          }
        }
        return;
      }

      // Fallback: use block-level representation for very large k (beyond our custom range)
      if (k > blockThreshold) {
        tileCount = n + 2 * k - 3;
        document.getElementById('tileCount').innerHTML = `For k = ${k} (n = ${n}), the minimum number of tiles is <strong>${tileCount}</strong> (= n + 2k − 3).`;
        for (let br = 0; br < k; br++) {
          for (let bc = 0; bc < k; bc++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.style.width = cellSize + 'px';
            cell.style.height = cellSize + 'px';
            cell.style.position = 'relative';
            if (br === bc) {
              cell.style.background = '#dddddd';
              const mini = document.createElement('div');
              mini.style.position = 'absolute';
              mini.style.width = Math.max(2, Math.floor(cellSize / 4)) + 'px';
              mini.style.height = Math.max(2, Math.floor(cellSize / 4)) + 'px';
              mini.style.background = '#ffffff';
              mini.style.border = '1px solid #333';
              mini.style.top = (cellSize - Math.floor(cellSize / 4)) / 2 + 'px';
              mini.style.left = (cellSize - Math.floor(cellSize / 4)) / 2 + 'px';
              cell.appendChild(mini);
            } else {
              const colorIndex = (br * k + bc) % palette.length;
              cell.style.background = palette[colorIndex];
            }
            gridDiv.appendChild(cell);
          }
        }
        return;
      }

      // Default general pattern for other small k values (should not execute for k ≤ 4)
      tileCount = n + 2 * k - 3;
      document.getElementById('tileCount').innerHTML = `For k = ${k} (n = ${n}), the minimum number of tiles is <strong>${tileCount}</strong> (= n + 2k − 3).`;
      for (let r = 0; r < n; r++) {
        for (let c = 0; c < n; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.style.width = cellSize + 'px';
          cell.style.height = cellSize + 'px';
          const blockRow = Math.floor(r / k);
          const blockCol = Math.floor(c / k);
          if (blockRow === blockCol) {
            if ((r % k) === (c % k)) {
              cell.style.background = '#ffffff';
              cell.style.border = '1px solid #333';
            } else {
              cell.style.background = '#dddddd';
            }
          } else {
            const colorIndex = (blockRow * k + blockCol) % palette.length;
            cell.style.background = palette[colorIndex];
          }
          gridDiv.appendChild(cell);
        }
      }
    }
    // Initialize on load
    window.onload = updateGrid;
  </script>
</body>
</html>
